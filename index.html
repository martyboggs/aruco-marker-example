<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<title>Three.js World</title>
	<style>
	body {
		margin: 0;
	}
	#video-el {
		display: absolute;
		object-fit: cover;
	}
	#canvases canvas {
		display: absolute;
		object-fit: cover;
		z-index: 2;
		/*display: block;
		position: absolute;
		width: 100%;
		height: 100%;*/
	}
	</style>
</head>
<body>
<div id="canvases"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>

<script src='js/lib/stats.min.js'></script>

<script src='js/lib/js-aruco/svd.js'></script>
<script src='js/lib/js-aruco/posit1-patched.js'></script>
<script src='js/lib/js-aruco/cv.js'></script>
<script src='js/lib/js-aruco/aruco.js'></script>
<script src="js/lib/threex.webcamgrabbing.js"></script>
<script src="js/lib/threex.jsarucomarker.js"></script>
<script>
// check for ssld
// if (!window.MediaStreamTrack || !window.MediaStreamTrack.getSources) throw new Error('MediaStreamTrack not found. Make sure there\'s a valid ssl certificate');


var renderStats = new Stats();
renderStats.setMode(0);
document.body.appendChild( renderStats.domElement );
renderStats.domElement.style.position = 'absolute';
renderStats.domElement.style.bottom = '0px';
renderStats.domElement.style.left = '0px';

var renderer = new THREE.WebGLRenderer({
	antialias: false,
	alpha: true,
});
document.getElementById('canvases').appendChild(renderer.domElement);
// array of functions for the rendering loop
var onRenderFcts = [];
// init scene and camera
var scene = new THREE.Scene()
var camera	= new THREE.PerspectiveCamera(40, 2, 0.01, 1000);
// var camera	= new THREE.PerspectiveCamera(75, 2, 0.1, 1000);
camera.position.z = 2;
//////////////////////////////////////////////////////////////////////////////////
// create a markerObject3D
//////////////////////////////////////////////////////////////////////////////////
var markerObject3D = new THREE.Object3D();
var mesh = new THREE.Object3D();
//////////////////////////////////////////////////////////////////////////////////
//		add an object in the markerObject3D
//////////////////////////////////////////////////////////////////////////////////
// add some debug display
(function () {
	new THREE.JSONLoader().load('js/models/pineapple.json', function (geometry, materials) {
		mesh = new THREE.Mesh(geometry, new THREE.MultiMaterial(materials));
		scene.add(mesh);
	});
}());

//////////////////////////////////////////////////////////////////////////////////
//		render the whole thing on the page
//////////////////////////////////////////////////////////////////////////////////
//handle window resize
window.addEventListener('resize', function () {
	resize();
}, false);
resize();

function resize() {
	var videoAr = 1.333;
	if (document.getElementById('video-el') && document.getElementById('video-el').videoWidth) {
		videoAr = document.getElementById('video-el').videoWidth / document.getElementById('video-el').videoHeight);
	}
	var w = parseInt(document.body.clientWidth);
	var h = parseInt(document.body.clientHeight);
	var screenAr = w / h;
	if (videoAr > screenAr) {
		renderer.setSize(h * videoAr, h);
		camera.aspect = h * videoAr / h;
		document.getElementById('video-el').style.width = h * videoAr + 'px';
		document.getElementById('video-el').style.height = h + 'px';
	} else {
		console.log('tall');
	}
	camera.updateProjectionMatrix();
}

// lights
var ambientLight = new THREE.AmbientLight(0xffffff, 1);
var pointLight = new THREE.PointLight(0xffffff, 1, 0, 2);
pointLight.position.set(0, 1.4, 3.4);
scene.add(pointLight, ambientLight);

// render the scene
onRenderFcts.push(function () {
	renderStats.begin();
	renderer.render( scene, camera );
	renderStats.end();
});
// run the rendering loop
var previousTime = performance.now()
requestAnimationFrame(function animate (now) {
	requestAnimationFrame(animate);
	onRenderFcts.forEach(function (onRenderFct) {
		onRenderFct(now, now - previousTime)
	});
	previousTime = now;
})


// init the marker recognition
var jsArucoMarker = new THREEx.JsArucoMarker();
var videoGrabbing = new THREEx.WebcamGrabbing();
jsArucoMarker.videoScaleDown = 2;
videoGrabbing.domElement.id = 'video-el';
document.body.appendChild(videoGrabbing.domElement);

var updateMesh = true;
var counterStart = 30;
var updateCounter = counterStart;

// process the image source with the marker recognition
onRenderFcts.push(function () {
	if (updateMesh) {
		var domElement	= videoGrabbing.domElement;
		var markers	= jsArucoMarker.detectMarkers(domElement);
		markers.forEach(function (marker) {
			jsArucoMarker.markerToObject3D(marker, markerObject3D);
		});
	}

	// move mesh
	mesh.position.x += (markerObject3D.position.x - mesh.position.x) / counterStart;
	mesh.position.y += (markerObject3D.position.y - mesh.position.y) / counterStart;
	mesh.position.z += (markerObject3D.position.z - mesh.position.z) / counterStart;
	mesh.rotation.x += (markerObject3D.rotation.x - mesh.rotation.x) / counterStart;
	mesh.rotation.y += (markerObject3D.rotation.y - mesh.rotation.y) / counterStart;
	mesh.rotation.z += (markerObject3D.rotation.z - mesh.rotation.z) / counterStart;
	mesh.scale.x += (markerObject3D.scale.x - mesh.scale.x) / counterStart;
	mesh.scale.y += (markerObject3D.scale.y - mesh.scale.y) / counterStart;
	mesh.scale.z += (markerObject3D.scale.z - mesh.scale.z) / counterStart;

	// update mesh sometimes
	if (updateCounter === 0) {
		updateCounter = counterStart;
		updateMesh = true;
	} else {
		updateCounter -= 1;
		updateMesh = false;
	}
});

</script>
</body>
</html>
