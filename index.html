<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<title>Three.js World</title>
</head>
<body>
<div id="canvases"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>

<script src='js/lib/stats.min.js'></script>

<script src='js/lib/js-aruco/svd.js'></script>
<script src='js/lib/js-aruco/posit1-patched.js'></script>
<script src='js/lib/js-aruco/cv.js'></script>
<script src='js/lib/js-aruco/aruco.js'></script>
<script src="js/lib/threex.webcamgrabbing.js"></script>
<script src="js/lib/threex.jsarucomarker.js"></script>
<script>
// check for ssld
// if (!window.MediaStreamTrack || !window.MediaStreamTrack.getSources) throw new Error('MediaStreamTrack not found. Make sure there\'s a valid ssl certificate');

var detectMarkersStats = new Stats();
detectMarkersStats.setMode( 1 );
document.body.appendChild( detectMarkersStats.domElement );
detectMarkersStats.domElement.style.position = 'absolute';
detectMarkersStats.domElement.style.bottom = '0px';
detectMarkersStats.domElement.style.right = '0px';

var renderStats = new Stats();
renderStats.setMode( 0 );
document.body.appendChild( renderStats.domElement );
renderStats.domElement.style.position = 'absolute';
renderStats.domElement.style.bottom = '0px';
renderStats.domElement.style.left = '0px';

var renderer = new THREE.WebGLRenderer({
	antialias: false,
	alpha: true,
});
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('canvases').appendChild(renderer.domElement);
// array of functions for the rendering loop
var onRenderFcts = [];
// init scene and camera
var scene = new THREE.Scene()
var camera	= new THREE.PerspectiveCamera(40, 2, 0.01, 1000);
// var camera	= new THREE.PerspectiveCamera(75, 2, 0.1, 1000);
camera.position.z = 2;
//////////////////////////////////////////////////////////////////////////////////
// create a markerObject3D
//////////////////////////////////////////////////////////////////////////////////
var markerObject3D = new THREE.Object3D();
var mesh = new THREE.Object3D();
//////////////////////////////////////////////////////////////////////////////////
//		add an object in the markerObject3D
//////////////////////////////////////////////////////////////////////////////////
// add some debug display
(function () {
	new THREE.JSONLoader().load('js/models/pineapple.json', function (geometry, materials) {
		mesh = new THREE.Mesh(geometry, new THREE.MultiMaterial(materials));
		mesh.scale.set(0.3, 0.3, 0.3);
		mesh.rotation.set(0, 90 * Math.PI / 180, 0);
		scene.add( mesh );
		// var mesh = new THREE.AxisHelper
		// markerObject3D.add( mesh );
	});
}());

//////////////////////////////////////////////////////////////////////////////////
//		render the whole thing on the page
//////////////////////////////////////////////////////////////////////////////////
// handle window resize
window.addEventListener('resize', function () {
	renderer.setSize(window.innerWidth, window.innerHeight);
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
}, false);

// lights
var ambientLight = new THREE.AmbientLight(0xffffff, 1);
var pointLight = new THREE.PointLight(0xffffff, 1, 10, 2);
pointLight.position.set(0, 1.4, 3.4);
scene.add(pointLight, ambientLight);

// render the scene
onRenderFcts.push(function () {
	renderStats.begin();
	renderer.render( scene, camera );
	renderStats.end();
});
// run the rendering loop
var previousTime = performance.now()
requestAnimationFrame(function animate (now) {
	requestAnimationFrame(animate);
	onRenderFcts.forEach(function (onRenderFct) {
		onRenderFct(now, now - previousTime)
	});
	previousTime = now;
})


// init the marker recognition
var jsArucoMarker = new THREEx.JsArucoMarker();
var videoGrabbing = new THREEx.WebcamGrabbing();
jsArucoMarker.videoScaleDown = 2;
document.body.appendChild(videoGrabbing.domElement);

var updateMesh = true;
var counterStart = 30;
var updateCounter = counterStart;

// process the image source with the marker recognition
onRenderFcts.push(function () {
	if (updateMesh) {
		var domElement	= videoGrabbing.domElement;
		detectMarkersStats.begin();
		var markers	= jsArucoMarker.detectMarkers(domElement);
		detectMarkersStats.end();
		markers.forEach(function (marker) {
			jsArucoMarker.markerToObject3D(marker, markerObject3D);
		});
	}
	// update mesh sometimes
	if (updateCounter === 0) {
		updateCounter = counterStart;
		updateMesh = true;
	} else {
		updateCounter -= 1;
		updateMesh = false;
		mesh.position.x += (markerObject3D.position.x - mesh.position.x) / counterStart;
		mesh.position.y += (markerObject3D.position.y - mesh.position.y) / counterStart;
		mesh.position.z += (markerObject3D.position.z - mesh.position.z) / counterStart;
		mesh.rotation.x += (markerObject3D.rotation.x - mesh.rotation.x) / counterStart;
		mesh.rotation.y += (markerObject3D.rotation.y - mesh.rotation.y) / counterStart;
		mesh.rotation.z += (markerObject3D.rotation.z - mesh.rotation.z) / counterStart;
		mesh.scale.x += (markerObject3D.scale.x - mesh.scale.x) / counterStart;
		mesh.scale.y += (markerObject3D.scale.y - mesh.scale.y) / counterStart;
		mesh.scale.z += (markerObject3D.scale.z - mesh.scale.z) / counterStart;
	}
});

</script>
</body>
</html>
